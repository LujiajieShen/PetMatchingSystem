diff --git a/release-notes/VERSION b/release-notes/VERSION
index b15ee48d..9bd1defb 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -19,6 +19,7 @@ New minor version.
 #98: Improve handling of failures for `BigDecimal`, for "NaN" (and infinity)
 #103: Add `JsonFactory.canHandleBinaryNatively`, `JsonGenerator.canWriteBinaryNatively`
  to let databind module detect level of support for binary data.
+#105: Parser parsers numbers eagerly; does not report error with missing space
 - Improve `DefaultPrettyPrinter`, `Lf2SpacesIndenter` (from databind #276)
 - Add `JsonGenerator.canOmitFields()` method to support discovery of
   positional formats, needed for handling of filtering for CSV
diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
index 00f49f25..e14f5021 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
@@ -761,17 +761,17 @@ public abstract class ParserBase
                 _numTypesValid = NR_LONG;
                 return;
             }
-            _parseSlowIntValue(expType, buf, offset, len);
+            _parseSlowInt(expType, buf, offset, len);
             return;
         }
         if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {
-            _parseSlowFloatValue(expType);
+            _parseSlowFloat(expType);
             return;
         }
         _reportError("Current token ("+_currToken+") not numeric, can not use numeric value accessors");
     }
     
-    private void _parseSlowFloatValue(int expType)
+    private void _parseSlowFloat(int expType)
         throws IOException, JsonParseException
     {
         /* Nope: floating point. Here we need to be careful to get
@@ -796,7 +796,7 @@ public abstract class ParserBase
         }
     }
     
-    private void _parseSlowIntValue(int expType, char[] buf, int offset, int len)
+    private void _parseSlowInt(int expType, char[] buf, int offset, int len)
         throws IOException, JsonParseException
     {
         String numStr = _textBuffer.contentsAsString();
diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
index ef263255..b99e2ef7 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
@@ -488,10 +488,13 @@ public abstract class ParserMinimalBase
         _reportError("Unexpected end-of-input"+msg);
     }
 
-    protected void _reportInvalidEOFInValue() throws JsonParseException
-    {
+    protected void _reportInvalidEOFInValue() throws JsonParseException {
         _reportInvalidEOF(" in a value");
     }
+
+    protected void _reportMissingRootWS(int ch) throws JsonParseException {
+        _reportUnexpectedChar(ch, "Expected space separating root-level values");
+    }
     
     protected void _throwInvalidSpace(int i)
         throws JsonParseException
diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
index a947fd6c..98b56302 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
@@ -945,10 +945,13 @@ public final class ReaderBasedJsonParser
                     reportUnexpectedNumberChar(ch, "Exponent indicator not followed by a digit");
                 }
             }
-
             // Got it all: let's add to text buffer for parsing, access
             --ptr; // need to push back following separator
             _inputPtr = ptr;
+            // As per #105, need separating space between root values; check here
+            if (_parsingContext.inRoot()) {
+                _verifyRootSpace(ch);
+            }
             int len = ptr-startPtr;
             _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
             return reset(negative, intLen, fractLen, expLen);
@@ -1078,6 +1081,9 @@ public final class ReaderBasedJsonParser
         // Ok; unless we hit end-of-input, need to push last char read back
         if (!eof) {
             --_inputPtr;
+            if (_parsingContext.inRoot()) {
+                _verifyRootSpace(c);
+            }
         }
         _textBuffer.setCurrentLength(outPtr);
         // And there we have it!
@@ -1152,6 +1158,32 @@ public final class ReaderBasedJsonParser
         return null;
     }
 
+    /**
+     * Method called to ensure that a root-value is followed by a space
+     * token.
+     *<p>
+     * NOTE: caller MUST ensure there is at least one character available;
+     * and that input pointer is AT given char (not past)
+     */
+    private final void _verifyRootSpace(int ch) throws IOException
+    {
+        // caller had pushed it back, before calling; reset
+        ++_inputPtr;
+        switch (ch) {
+        case ' ':
+        case '\t':
+            return;
+        case '\r':
+            _skipCR();
+            return;
+        case '\n':
+            ++_currInputRow;
+            _currInputRowStart = _inputPtr;
+            return;
+        }
+        _reportMissingRootWS(ch);
+    }
+    
     /*
     /**********************************************************
     /* Internal methods, secondary parsing
diff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
index 836c0afa..83ae5b7a 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
@@ -732,7 +732,7 @@ public final class UTF8StreamJsonParser
         case '7':
         case '8':
         case '9':
-            t = parseNumberText(i);
+            t = _parseNumber(i);
             break;
         default:
             t = _handleUnexpectedValue(i);
@@ -784,7 +784,7 @@ public final class UTF8StreamJsonParser
         case '7':
         case '8':
         case '9':
-            return (_currToken = parseNumberText(i));
+            return (_currToken = _parseNumber(i));
         }
         return (_currToken = _handleUnexpectedValue(i));
     }
@@ -973,7 +973,7 @@ public final class UTF8StreamJsonParser
         case '7':
         case '8':
         case '9':
-            _nextToken = parseNumberText(i);
+            _nextToken = _parseNumber(i);
             return;
         }
         _nextToken = _handleUnexpectedValue(i);
@@ -1041,7 +1041,7 @@ public final class UTF8StreamJsonParser
         case '8':
         case '9':
 
-            t = parseNumberText(i);
+            t = _parseNumber(i);
             break;
         default:
             t = _handleUnexpectedValue(i);
@@ -1181,7 +1181,7 @@ public final class UTF8StreamJsonParser
      * deferred, since it is usually the most complicated and costliest
      * part of processing.
      */
-    protected JsonToken parseNumberText(int c)
+    protected JsonToken _parseNumber(int c)
         throws IOException, JsonParseException
     {
         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
@@ -1235,11 +1235,15 @@ public final class UTF8StreamJsonParser
             outBuf[outPtr++] = (char) c;
         }
         if (c == '.' || c == 'e' || c == 'E') {
-            return _parseFloatText(outBuf, outPtr, c, negative, intLen);
+            return _parseFloat(outBuf, outPtr, c, negative, intLen);
         }
-
+        
         --_inputPtr; // to push back trailing char (comma etc)
         _textBuffer.setCurrentLength(outPtr);
+        // As per #105, need separating space between root values; check here
+        if (_parsingContext.inRoot()) {
+            _verifyRootSpace(c);
+        }
 
         // And there we have it!
         return resetInt(negative, intLen);
@@ -1262,7 +1266,7 @@ public final class UTF8StreamJsonParser
             int c = (int) _inputBuffer[_inputPtr++] & 0xFF;
             if (c > INT_9 || c < INT_0) {
                 if (c == '.' || c == 'e' || c == 'E') {
-                    return _parseFloatText(outBuf, outPtr, c, negative, intPartLength);
+                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);
                 }
                 break;
             }
@@ -1275,6 +1279,10 @@ public final class UTF8StreamJsonParser
         }
         --_inputPtr; // to push back trailing char (comma etc)
         _textBuffer.setCurrentLength(outPtr);
+        // As per #105, need separating space between root values; check here
+        if (_parsingContext.inRoot()) {
+            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);
+        }
 
         // And there we have it!
         return resetInt(negative, intPartLength);
@@ -1318,7 +1326,7 @@ public final class UTF8StreamJsonParser
         return ch;
     }
     
-    private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c,
+    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,
             boolean negative, int integerPartLength)
         throws IOException, JsonParseException
     {
@@ -1401,13 +1409,44 @@ public final class UTF8StreamJsonParser
         // Ok; unless we hit end-of-input, need to push last char read back
         if (!eof) {
             --_inputPtr;
+            // As per #105, need separating space between root values; check here
+            if (_parsingContext.inRoot()) {
+                _verifyRootSpace(c);
+            }
         }
         _textBuffer.setCurrentLength(outPtr);
 
         // And there we have it!
         return resetFloat(negative, integerPartLength, fractLen, expLen);
     }
-    
+
+    /**
+     * Method called to ensure that a root-value is followed by a space
+     * token.
+     *<p>
+     * NOTE: caller MUST ensure there is at least one character available;
+     * and that input pointer is AT given char (not past)
+     */
+    private final void _verifyRootSpace(int ch) throws IOException
+    {
+        // caller had pushed it back, before calling; reset
+        ++_inputPtr;
+        // TODO? Handle UTF-8 char decoding for error reporting
+        switch (ch) {
+        case ' ':
+        case '\t':
+            return;
+        case '\r':
+            _skipCR();
+            return;
+        case '\n':
+            ++_currInputRow;
+            _currInputRowStart = _inputPtr;
+            return;
+        }
+        _reportMissingRootWS(ch);
+    }
+
     /*
     /**********************************************************
     /* Internal methods, secondary parsing
@@ -2559,10 +2598,6 @@ public final class UTF8StreamJsonParser
                 }
                 break;
             default: // e.g. -1
-                // Is this good enough error message?
-                if (i < 32) {
-                    _throwInvalidSpace(i);
-                }
                 _reportInvalidChar(i);
             }
         }
diff --git a/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java b/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java
index 6e0c3ac9..8476bc4b 100644
--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java
+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java
@@ -9,7 +9,6 @@ import com.fasterxml.jackson.core.JsonToken;
 public class TestParserErrorHandling
     extends com.fasterxml.jackson.test.BaseTest
 {
-
     public void testInvalidKeywordsStream() throws Exception {
         _testInvalidKeywords(true);
     }
@@ -18,6 +17,15 @@ public class TestParserErrorHandling
         _testInvalidKeywords(false);
     }
 
+    // Tests for #105 ("eager number parsing misses errors")
+    public void testMangledNumbersBytes() throws Exception {
+        _testMangledNumbers(true);
+    }
+
+    public void testMangledNumbersChars() throws Exception {
+        _testMangledNumbers(false);
+    }
+    
     /*
     /**********************************************************
     /* Helper methods
@@ -74,4 +82,30 @@ public class TestParserErrorHandling
             jp.close();
         }
     }
+
+    private void _testMangledNumbers(boolean useStream) throws Exception
+    {
+        String doc = "123true";
+        JsonParser jp = useStream ? createParserUsingStream(doc, "UTF-8")
+                : createParserUsingReader(doc);
+        try {
+            JsonToken t = jp.nextToken();
+            fail("Should have gotten an exception; instead got token: "+t);
+        } catch (JsonParseException e) {
+            verifyException(e, "expected space");
+        }
+        jp.close();
+
+        // Also test with floats
+        doc = "1.5false";
+        jp = useStream ? createParserUsingStream(doc, "UTF-8")
+                : createParserUsingReader(doc);
+        try {
+            JsonToken t = jp.nextToken();
+            fail("Should have gotten an exception; instead got token: "+t);
+        } catch (JsonParseException e) {
+            verifyException(e, "expected space");
+        }
+        jp.close();
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/core/json/TestRootValueParsing.java b/src/test/java/com/fasterxml/jackson/core/json/TestRootValueParsing.java
new file mode 100644
index 00000000..5078f4da
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/core/json/TestRootValueParsing.java
@@ -0,0 +1,52 @@
+package com.fasterxml.jackson.core.json;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+
+public class TestRootValueParsing
+    extends com.fasterxml.jackson.test.BaseTest
+{
+    private final JsonFactory JSON_F = new JsonFactory();
+
+    public void testSimpleNumbers() throws Exception
+    {
+        _testSimpleNumbers(false);
+        _testSimpleNumbers(true);
+    }
+
+    private void _testSimpleNumbers(boolean useStream) throws Exception
+    {
+        final String DOC = "1 2\t3\r4\n5\r\n6\r\n   7";
+        JsonParser jp = useStream ?
+                createParserUsingStream(JSON_F, DOC, "UTF-8")
+                : createParserUsingReader(JSON_F, DOC);
+        for (int i = 1; i <= 7; ++i) {
+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());
+            assertEquals(i, jp.getIntValue());
+        }
+        assertNull(jp.nextToken());
+        jp.close();
+    }
+
+    public void testSimpleBooleans() throws Exception
+    {
+        _testSimpleBooleans(false);
+        _testSimpleBooleans(true);
+    }
+
+    private void _testSimpleBooleans(boolean useStream) throws Exception
+    {
+        final String DOC = "true false\ttrue\rfalse\ntrue\r\nfalse\r\n   true";
+        JsonParser jp = useStream ?
+                createParserUsingStream(JSON_F, DOC, "UTF-8")
+                : createParserUsingReader(JSON_F, DOC);
+        boolean exp = true;
+        for (int i = 1; i <= 7; ++i) {
+            assertToken(exp ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, jp.nextToken());
+            exp = !exp;
+        }
+        assertNull(jp.nextToken());
+        jp.close();
+    }
+}
